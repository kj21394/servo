
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module servo_control(

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_SCK,
	output		          		ADC_SDI,
	input 		          		ADC_SDO,

	//////////// ARDUINO //////////
	inout 		    [15:0]		ARDUINO_IO,
	inout 		          		ARDUINO_RESET_N,

	//////////// CLOCK //////////
	input 		          		FPGA_CLK1_50,
	input 		          		FPGA_CLK2_50,
	input 		          		FPGA_CLK3_50,

	//////////// HDMI //////////
	inout 		          		HDMI_I2C_SCL,
	inout 		          		HDMI_I2C_SDA,
	inout 		          		HDMI_I2S,
	inout 		          		HDMI_LRCLK,
	inout 		          		HDMI_MCLK,
	inout 		          		HDMI_SCLK,
	output		          		HDMI_TX_CLK,
	output		          		HDMI_TX_DE,
	output		    [23:0]		HDMI_TX_D,
	output		          		HDMI_TX_HS,
	input 		          		HDMI_TX_INT,
	output		          		HDMI_TX_VS,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		reg  [7:0]		LED,

	//////////// SW //////////
	input 		     [3:0]		SW,

	//////////// GPIO_0, GPIO connect to RFS - RF and Sensor //////////
	inout 		          		BT_KEY,
	input 		          		BT_UART_RX,
	output		          		BT_UART_TX,
	input 		          		LSENSOR_INT,
	inout 		          		LSENSOR_SCL,
	inout 		          		LSENSOR_SDA,
	inout 		          		MPU_AD0_SDO,
	output		          		MPU_CS_n,
	output		          		MPU_FSYNC,
	input 		          		MPU_INT,
	inout 		          		MPU_SCL_SCLK,
	inout 		          		MPU_SDA_SDI,
	input 		          		RH_TEMP_DRDY_n,
	inout 		          		RH_TEMP_I2C_SCL,
	inout 		          		RH_TEMP_I2C_SDA,
	inout 		     [7:0]		TMD_D,
	input 		          		UART2USB_CTS,
	output		          		UART2USB_RTS,
	input 		          		UART2USB_RX,
	output		          		UART2USB_TX,
	output		          		WIFI_EN,
	output		          		WIFI_RST_n,
	input 		          		WIFI_UART0_CTS,
	output		          		WIFI_UART0_RTS,
	input 		          		WIFI_UART0_RX,
	output		          		WIFI_UART0_TX,
	input 		          		WIFI_UART1_RX,
	inout            [35:0]    GPIO_1
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

wire 				rts; // request to send		  
wire 				cts; // clear to send
wire 				rxd;
wire 				txd;
wire	 [7:0]   uart_data;
wire	         rdempty;
wire	         write;
reg           m_write; 
reg	     	   read;
reg	         cnt;
reg  [7:0]     data1;
wire [7:0]		d1;
reg  [7:0]     data2;
reg  [7:0]     data3;
reg 				data_full;
reg  [1:0]		data_count;
//=======================================================
//  Structural coding
//=======================================================

// UART Controller
uart_control UART0(

	.clk(FPGA_CLK1_50),
	.reset_n(KEY[0]),
	// tx
	.write(m_write),
	.writedata(data1),

	// rx
	.read(read),
	.readdata(uart_data),
	.rdempty(rdempty),
	//
	.uart_clk_25m(cnt),
	.uart_tx(BT_UART_TX),
	.uart_rx(BT_UART_RX)
	
);	

//read
always@(posedge FPGA_CLK1_50)
begin
  if (~rdempty)
		read <= 1;
  else
		read <= 0;
end
assign  write = ( read & (~rdempty) );


always@(posedge FPGA_CLK1_50 or negedge KEY[0])
begin
  if(!KEY[0])
  begin
    LED <= 0;
	 data_count <= 2'b00;
  end
  else if(KEY[0] & write)
  begin
	 if (data_count == 2'b00)
	 begin 
		data1 <= uart_data[7:0];
	 end
	 else if (data_count == 2'b01)
	 begin
	   data2 <= uart_data[7:0]; 
	 end
	 else if (data_count == 2'b10)
	 begin
		data3 <= uart_data[7:0];
	   m_write = 1;	
	 end
	 else if (data_count == 2'b11)
	 begin 
		data_count <= 2'b00;
	 end
	 if (data1 == 8'h36 && data2 == 8'h38 && data3 == 8'h34)
	 begin 
		LED <= LED | 8'hf;
	 end 
	 else
	 begin
		LED[7] <= 1;
	 end
    data_count <= data_count + 2'b01; 
  end
  else
  begin
    LED <= LED;
	 m_write = 0;
  end
end


wire [7:0] angle;
wire [2:0] speed;
wire [7:0] oangle;
wire pwm; 
wire rst; 
wire [31:0] pwmangle;
assign GPIO_1[0] = pwm; 
assign rst = 1;// ~SW[2];
`define DUR_CLOCK_NUM ( 50000000/50)            // clock count in 20 ms
`define DEGREE_MAX    ( `DUR_CLOCK_NUM*25/200) // 2.5 ms 125000
`define DEGREE_MIN    ( `DUR_CLOCK_NUM*5/200)  // 0.5 ms 25000
wire [31:0] PwmAngle;


interface h0(
	.clk(FPGA_CLK1_50),
	.rst(rst),
	.angle(angle),
	.speed(speed),
	.out_angle(oangle)

);


assign  PwmAngle = (((`DEGREE_MAX - `DEGREE_MIN)/180)*oangle)+`DEGREE_MIN;

pwm_gen p0(
	.clk (FPGA_CLK1_50),
	.rst (rst),
	.on_period (PwmAngle),
	.total_dur (DUR_CLOCK_NUM),
	.PWM (pwm)
);


always@(posedge FPGA_CLK1_50)
	cnt <= cnt + 1;


	

endmodule
