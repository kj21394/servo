
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module servo_control(

	//////////// CLOCK //////////
	input 		          		FPGA_CLK1_50,
	input 		          		FPGA_CLK2_50,
	input 		          		FPGA_CLK3_50,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		  reg   [7:0]		LED,

	//////////// SW //////////
	input 		     [3:0]		SW,

	//////////// GPIO_0, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO_0,

	//////////// GPIO_1, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO_1
);


function integer num(); 
input [7:0] inp_data;
begin
	case(inp_data)
		8'h30 : num = 0;
		8'h31 : num = 1;
		8'h32 : num = 2;
		8'h33 : num = 3;
		8'h34 : num = 4;
		8'h35 : num = 5;
		8'h36 : num = 6;
		8'h37 : num = 7;
		8'h38 : num = 8;
		8'h39 : num = 9;
		default: num = 0;  
	endcase
end
endfunction

uart_control UART0(

	.clk(FPGA_CLK1_50),
	.reset_n(KEY[0]),
	// tx
	.write(m_write),
	.writedata(uart_data),

	// rx
	.read(read),
	.readdata(uart_data),
	.rdempty(rdempty),
	//
	.uart_clk_25m(cnt),
	.uart_tx(GPIO_0[19]),
	.uart_rx(GPIO_0[18])
	
);	

//=======================================================
//  REG/WIRE declarations
//=======================================================
wire [7:0]  Angle;
wire        Pwm_0;
wire        RESET_N;
wire 				rts; // request to send		  
wire 				cts; // clear to send
wire 				rxd;
wire 				txd;
wire	 [7:0]   uart_data;
wire	         rdempty;
wire	         write;
wire [7:0] angle;
wire [2:0] speed;

wire [7:0] oangle;
reg    [7:0]       m_write; 
reg	     	   read;
reg	         cnt;
reg  [7:0]     data1 [0:2];
wire [7:0]		d1;
reg  [7:0]     data2;
reg  [7:0]     data3;
reg 				data_full;
reg  [1:0]		data_count = 2'b00;
reg  [7:0] servo_angle;
reg  [7:0] servo_speed;

//=======================================================
//  Structural coding
//=======================================================
assign GPIO_1[0] = Pwm_0;
assign GPIO_1[2] = Pwm_0;
assign GPIO_1[4] = Pwm_0;


assign RESET_N = 1;// ~SW[2];

always@(posedge FPGA_CLK1_50)
begin
  if (~rdempty)
		read <= 1;
  else
		read <= 0;
end
assign  write = ( read & (~rdempty) );

integer x;
integer y;
integer z;
integer xyz;
always@(posedge FPGA_CLK1_50 or negedge KEY[0])
begin
  if(!KEY[0])
  begin
    LED <= 0;
	 data_count <= 2'b00;
  end
  else if(KEY[0] & write)
  begin
	 if (data_count < 2'b11)
	 begin
		data1[data_count] = uart_data[7:0];
	 end
	 if (data_count == 2'b10)
	 begin 
		if (data1[0] == 8'h61 && data1[1] == 8'h61 && data1[2] == 8'h61)
		begin 
			servo_speed = servo_speed + 2;
		end
		else if (data1[0] == 8'h62 && data1[1] == 8'h62 && data1[2] == 8'h62)
		begin 
			servo_speed = servo_speed - 2;
		end
		else if (data1[0] == 8'h63 && data1[1] == 8'h63 && data1[2] == 8'h63)
		begin 
			m_write <= 2;
		end
		else if (data1[0] == 8'h64 && data1[1] == 8'h64 && data1[2] == 8'h64)
		begin 
			m_write <= 3;
		end
		else if (data1[0] == 8'h65 && data1[1] == 8'h65 && data1[2] == 8'h65)
		begin 
			m_write <= 4;
		end
		else
		begin
			x <= num(data1[0]) * 100;
			y <= num(data1[1]) * 10;
			z <= num(data1[2]);
			xyz = x+y+z;
			m_write <=1;
		end
	 end 
	 else if(data_count == 2'b11)
	 begin 
		data_count <= 2'b00;
		m_write <= 0;
	 end
    data_count <= data_count + 2'b01; 
  end
  else
  begin
    LED <= LED;
	 m_write = 0;
  end
end

always@(posedge FPGA_CLK1_50)
begin
	if (m_write==1)
	begin
		xyz = x + y + z;
		if (xyz > 180)
			servo_angle = 180;
		else
			servo_angle = xyz;
	end
	else if (m_write==2)
	begin 
		servo_angle = servo_angle;
	end
	else if (m_write==3)
	begin 
		servo_angle = 180;
	end
	else if (m_write==4)
	begin 
		servo_angle = 0;
	end	
end

assign angle = servo_angle;
assign speed = servo_speed;

UI h0(

  .clk  ( FPGA_CLK1_50 ),
  .rst( RESET_N ),
  .angle  ( angle),
  .speed   ( speed ),
  .out_angle( oangle)

);


`define DUR_CLOCK_NUM ( 50000000/50)            // clock count in 20 ms
`define DEGREE_MAX    ( `DUR_CLOCK_NUM*25/200) // 2.5 ms 125000
`define DEGREE_MIN    ( `DUR_CLOCK_NUM*5/200)  // 0.5 ms 25000
wire [31:0] PwmAngle;
assign  PwmAngle = (((`DEGREE_MAX - `DEGREE_MIN)/180)*oangle)+`DEGREE_MIN;


PWM_Geneator p0(
	.clk      ( FPGA_CLK1_50 ),
	.rst  ( RESET_N      ),
	//
	.on_period ( PwmAngle),
	.total_dur( `DUR_CLOCK_NUM ),
	//
	.PWM      ( Pwm_0 )
);



always@(posedge FPGA_CLK1_50)
	cnt <= cnt + 1;


endmodule
